package com.syncron.rebind;

import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;

import com.syncron.shared.Action;
import com.syncron.shared.HandlesChange;

public class SimplePropertyObjectGenerator {
	private final String typeName;
	private final String packageName;
	private final Class<?> type;
	private final String result;

	public SimplePropertyObjectGenerator(String typeName, String suffix) throws ClassNotFoundException {
		this(Class.forName(typeName), suffix);
	}

	public SimplePropertyObjectGenerator(Class<?> type, String suffix) {
		this.type = type;
		this.typeName = type.getSimpleName() + suffix;
		this.packageName = type.getPackage().getName();
		this.result = generateClass();
	}

	public String getResult() {
		return result;
	}

	public String getPackageName() {
		return packageName;
	}

	public String getTypeName() {
		return typeName;
	}

	private String generateClass() {
		// get print writer that receives the source code
		ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
		SourceWriter writer = new SourceWriter(new OutputStreamWriter(byteArrayOutputStream));

		writer.println("package " + packageName + ";");
		writer.println("import java.util.Arrays;");
		writer.println("import java.util.List;");
		writer.println("import java.util.Set;");
		writer.println("import java.util.HashSet;");
		writer.println("import " + HandlesChange.class.getName() + ";");
		writer.println();
		writer.println("/** Generated by {@link " + SimplePropertyObjectGenerator.class.getCanonicalName() + "} */");
		writer.openBlock("public class " + typeName + " implements ReflectsObject");
			generateEventTargetsField(writer);
			writer.println();
			generateConstructor(writer);
			writer.println();
			generateFieldNames(writer);
			writer.println();
			generateGet(writer);
			writer.println();
			generateActions(writer);
			writer.println();
			generateAction(writer);
		writer.println();
		generateAddEventTarget(writer);
		writer.closeBlock();

		return writer.toString();
	}

	private void generateEventTargetsField(SourceWriter writer) {
		writer.println("Set<" + HandlesChange.class.getSimpleName() + "> eventTargets = new "
				+ HashSet.class.getSimpleName() + "();");
	}

	private void generateAddEventTarget(SourceWriter writer) {
		writer.openBlock("@Override public void addEventTarget(" + HandlesChange.class.getSimpleName()
				+ " handlesChange)");
		writer.println("eventTargets.add(handlesChange);");
		writer.closeBlock();
	}

	private void generateAction(SourceWriter writer) {
		writer.openBlock("@Override public void action(String actionName)");

		for (String actionName : getActionNames()) {
			writer.openBlock("if (\"" + actionName + "\".equals(actionName))");
				writer.println("object." + actionName + "();");
				writer.openBlock("for(HandlesChange handlesChange : eventTargets)");
					writer.println("handlesChange.handleChange();");
				writer.closeBlock();
				writer.doReturn("");
			writer.closeBlock();
		}

		writer.println("throw new IllegalArgumentException();");
		writer.closeBlock();

	}

	private void generateActions(SourceWriter writer) {
		writer.openBlock("@Override public List<String> actions()");
			writer.print("return Arrays.asList(");
			Iterator<String> iterator = getActionNames().iterator();
			writer.printList(iterator);
			writer.println(");");
		writer.closeBlock();
	}

	private Iterable<String> getActionNames() {
		Method[] methods = type.getDeclaredMethods();
		List<String> actions = new ArrayList<String>();

		for (Method method : Arrays.asList(methods)) {
			if (method.getAnnotation(Action.class) != null) {
				actions.add(method.getName());
			}
		}
		return actions;
	}

	private void generateConstructor(SourceWriter sourceWriter) {
		sourceWriter.println("private final " + type.getSimpleName() + " object;");
		sourceWriter.openBlock("public " + typeName + "(" + type.getSimpleName() + " object)");
			sourceWriter.println("super();");
			sourceWriter.println("this.object = object;");
		sourceWriter.closeBlock();
	}

	private void generateFieldNames(SourceWriter sourceWriter) {
		sourceWriter.openBlock("@Override public List<String> fieldNames()");
			sourceWriter.print("return Arrays.asList(");
			sourceWriter.printList(getProperties(type.getDeclaredFields()));
			sourceWriter.println(");");
		sourceWriter.closeBlock();
	}

	private List<String> getProperties(Field[] declaredFields) {
		Iterable<Field> fields = Arrays.asList(declaredFields);
		List<String> result = new ArrayList<String>();
		for (Field field : fields) {
			result.add(field.getName());
		}
		return result;
	}

	private void generateGet(SourceWriter sourceWriter) {
		sourceWriter.openBlock("@Override public Object get(String fieldName)");

		Field[] declaredFields = type.getDeclaredFields();

		Iterator<String> iterator = getProperties(declaredFields).iterator();
		sourceWriter.println("if (0 == 1) {");
		while (iterator.hasNext()) {
			String name = iterator.next();
			sourceWriter.println("} else if (\"" + name + "\".equals(fieldName)) {");
			sourceWriter.indent();
				sourceWriter.doReturn("object." + name);
			sourceWriter.outdent();
		}
		sourceWriter.println("}");
		sourceWriter.println("throw new IllegalArgumentException();");
		sourceWriter.closeBlock();
	}

	public static void main(String[] args) throws IOException, ClassNotFoundException {
		File dirToLookForClasses = new File("src/com/syncron/shared/");
		final String suffix = "$Properties";

		System.out.println("I'm here: " + dirToLookForClasses.getAbsolutePath());
		System.out.println("I'm going to filter these: " + Arrays.toString(dirToLookForClasses.list()));

		ArrayList<Class<?>> names = findClasses(dirToLookForClasses);

		for (Class<?> type : names) {
			SimplePropertyObjectGenerator generator = new SimplePropertyObjectGenerator(type, suffix);
			String newAbsoluteClassPath = dirToLookForClasses.getAbsolutePath() + "/" + type.getSimpleName() + suffix + ".java";
			FileWriter fileWriter = new FileWriter(new File(newAbsoluteClassPath));
			fileWriter.write(generator.getResult());
			fileWriter.close();
			System.out.println("Generated: " + newAbsoluteClassPath);
		}
	}

	private static ArrayList<Class<?>> findClasses(File dirToLookForClasses)
			throws FileNotFoundException, IOException, ClassNotFoundException {
		ArrayList<Class<?>> names = new ArrayList<Class<?>>();
		for (String fileName : dirToLookForClasses.list()) {
			File file = new File(dirToLookForClasses + "/" + fileName);

			if ( ! file.isFile()) { continue; }

			if (implementsModel(file)) {
				String className = "com.syncron.shared." + fileName.substring(0, fileName.length() - 5);
				names.add(Class.forName(className));
			}
		}
		return names;
	}

	private static boolean implementsModel(File file) throws IOException,
			ClassNotFoundException {
		BufferedReader fileReader = new BufferedReader(new FileReader(file));
		String line = "";
		while((line = fileReader.readLine()) != null) {
			if (line.contains("implements Model")) {
				return true;
			}
		}
		return false;
	}

}